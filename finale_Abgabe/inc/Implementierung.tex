\chapter{Implementierung} \label{ch:Implementierung}
In diesem Kapitel wird anfangs die eingesetzte Entwicklungsumgebung für die Programmierung des Regelgesetzes vorgestellt. Daraufhin wird die allgemeine Vorgehensweise der praktischen Umsetzung der Implementierung des Ballbot's erläutert.   


\section{Entwicklungsumgebung}
Als Entwicklungsumgebung für den Zustandsregler des Ballbot's wird die ArduinoIDE \footnote{https://www.arduino.cc/en/Main/Software} eingesetzt, die in Abbildung \ref{fig:IDE} abgebildet ist. Die Hauptbestandteile dieser Entwicklungsumgebung umfasst einen Texteditor für das eigentliche Programm, eine Konsole für Fehler- und Kompilierungsmeldungen und einen seriellen Monitor für das Senden und Empfangen von Daten zwischen Computer und Board. Weiterhin eignet sich die Entwicklungsumgebung für den Einsatz, da ab der Version 1.6.4 das eingesetzte OpenCR-Board unterstützt. Allerdings muss die dafür nötige Bibliothek über den Boardverwalter nachinstalliert werden \cite{openCR} \cite{Arduino}.
\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.70\textwidth]{Bilder/Florian/ArduinoIDE.PNG}
	\caption{Arduino Entwicklungsumgebung}
	\label{fig:IDE}
\end{figure}

Die Grundstruktur eines Programms, die im Listing \ref{lst:Programm} dargestellt ist, gliedert sich in zwei Bereiche. In der Setup-Funktionen, die nur einmal beim Start des Board ausgeführt wird, werden verschieden Initialisierungen für den späteren Programmablauf festgelegt. Bei der Loop-Funktion handelt es sich um das eigentliche Programm, die als endlose Schleife durchlaufen wird. Werden für das Programm noch weitere Funktionen bzw. Variablen benötigt, müssen diese am Anfang oder am Ende eines Programms definiert werden \cite{bruehl}.

\begin{lstlisting}[label=lst:Programm, style = C_colored_smallfont, caption=Grundstruktur eines Arduino-Programmes\cite{bruehl} ]
void setup()	{
		// Diese Funktion wird nur beim Starten 
		// des entsprechen Boards einmal ausgeführt
}

void loop()	{
		// Diese Funktion in einer endlosen Schleife 
		// durchlaufen
}
\end{lstlisting}
Um die Übersichtlichkeit zu steigern, können Funktionen und Klassendefinitionen in separaten Dateien ausgelagert werden und im Hauptprogramm eingebunden werden. 

\section{Hauptprogramm}
Die benötigten Daten für die Regelung werden nach dem EVA-Prinzip (Eingabe, Verarbeitung, Ausgabe) verarbeitet. Das bedeutet, dass das OpenCR-Board die benötigten Sensordaten des Gyroskops empfängt, entsprechend dem Regelgesetz aus Gl. \ref{eq:Regelgesetz} verarbeitet und die entsprechenden Stellgrößen an die einzelnen Motoren weiterleitet. Nachfolgend werden die einzelnen Schritte näher erläutert.

\subsection{Initialisierung Komponenten}
Für die Implementierung der Zustandsregelung müssen zunächst die inertiale Messeinheit, die Motoren und der Hardware-Interrupt initialisiert werden. Hierzu wird die Setup-Funktion benutzt.

Bei der Initialisierung der IMU bzw. des gesamten Systems muss darauf geachtet werden, die richtige Update-Frequenz festzulegen bzw. zu übergeben, damit das Gyroskop in möglichst kurzen Zeitabständen aktualisierte Daten zur Verfügung stellt und das System die aktuellen Stellgrößen berechnen kann.

Da der Ballbot seine Gleichgewichtslage durch das Aufbringen von entsprechenden Drehmomenten auf den Ball versucht zu halten, stellen diese  gleichzeitig die Stellgröße des Systems dar. Daher müssen die drei Motoren zu Beginn auf die stromgeregelte Betriebsart konfiguriert und für den Einsatz freigeben werden. Die entsprechenden Adressen und Werte sind dem Datenblatt \cite{XM430} zu entnehmen.

Damit die Berechnung des Regelgesetzes nach Gl. \ref{eq:Regelgesetz} zu den Zeitpunkten der Aktualisierungsfrequenz durchgeführt werden kann, wird ein Hardware-Timer initialisiert, der als Interrupt arbeitet und in festgelegten Zeitabständen das Hauptprogramm des Mikrocontrollers unterbricht und eine Ausnahmeroutine aufruft. Die auszuführenden Funktionen der Routine sind für die Berechnung der Stellgröße zuständig. Die Abbildung \ref{fig:ISP} zeigt die Funktionsweise eines Interrupts.   

\begin{figure}[h!]
\centering
\scalebox{0.7}{
\begin{tikzpicture}[auto, thick ,node distance=0.5cm]
% Definition of blocks:
\usetikzlibrary{positioning,arrows,calc}
\tikzset{%
  block/.style    = {draw, thick, rectangle,  rounded corners, minimum height = 1.5em, minimum width = 8em, node distance = 1.5cm},
  %sum/.style      = {draw, circle, node distance = 1.5cm}, % Adder
	%join/.style			= {coordinate}, 
  input/.style    = {coordinate, node distance = 2cm} % Input
  %output/.style   = {coordinate} % Output
}

\draw
	node [block](Reset){Reset}
	node [block, below = of Reset] (Setup){setup()}
	node [input, below = of Setup] (Verzweigung) {}
	node [block, below = of Verzweigung] (Loop) {loop()}
	node [input, below = of Loop] (Temp1) {}
	node [input, right = of Temp1] (Temp2) {}
	node [input, right = of Verzweigung] (Temp3) {};
	
	
\draw[->](Reset) -- (Setup);	
\draw[-](Setup) -- (Verzweigung);
\draw[->](Verzweigung) -- (Loop);
\draw[-](Loop) -- (Temp1);
\draw[-](Temp1) -- (Temp2);
\draw[-](Temp2) -- (Temp3);
\draw[->](Temp3) -- (Verzweigung);


\draw
	node [input, right = of Reset] (Temp4) {}
	node [block, right = of Temp4] (Int) {Interrupt}
	node [block, below = of Int] (IMU){readIMU()}
	node [block, below = of IMU] (Regler){computeControler()}
	node [block, below = of Regler] (Torque) {computeTorques()}
	node [block, below = of Torque] (Return) {Return};

\draw[->](Int) -- (IMU);	
\draw[->](IMU) -- (Regler);
\draw[->](Regler) -- (Torque);
\draw[->](Torque) -- (Return);

\end{tikzpicture}
}
\caption{Funktionsweise des Interrupts und dem damit verbunden Aufrufen der Serviceroutine}
\label{fig:ISP}
\end{figure}

\subsection{Einlesen der Sensordaten}
Der Zugriff auf die Winkel und Winkelgeschwindigkeiten wird durch das Einbinden der Bibliothek der inertialen Messeinheit hergestellt. Für die weitere Datenverarbeitung müssen die Winkel und Winkelgeschwindigkeiten, die in der Einheit $\circ$ und $1/min$ angegeben sind, mit einer entsprechenden Funktion in die Einheit $\text{rad}$ und $\text{rad/s}$ konvertiert werden. Die Abbildung \ref{fig:Winkel} zeigt die Winkel $\vartheta_{x}$ und die entsprechenden Winkelgeschwindigkeiten $\dot{\vartheta}_{x}$. Aufgrund der höheren Übersichtlichkeit sind diese in $\text{Grad}$ und $\text{Grad/s}$ angeben. Zudem ist zu erkennen, dass die Winkel mit einem Rauschen überlagert sind. 

\begin{figure}[h!]
\centering
\input{Bilder/Florian/Daten/Winkel.tex}
\caption{Darstellung der Winkel $\vartheta_{x}$ und Winkelgeschwindigkeit $\dot{\vartheta}_{x}$}
\label{fig:Winkel}
\end{figure}

Um das Rauschen zu verringern, werden die letzten drei Sensorwerte der Winkel und Winkelgeschwindigkeiten gespeichert, aufsummiert und davon der Mittelwert gebildet. Das Ergebnis ist in Abbildung \ref{fig:Filter} zu sehen. 

\begin{figure}[h!]
	\centering
	\input{./Bilder/Florian/Filter.tex}
	\caption{Beispielhafter Vergleich zwischen ungefilterten(blau) und gefilterten Messwinkel}
	\label{fig:Filter}
\end{figure}


\subsection{Verarbeitung Sensordaten}
Mit den ausgelesenen Sensordaten können die einzelnen virtuellen Drehmomente für die entsprechenden Ebenen berechnet werden. Das virtuelle Drehmoment für die $xy$-Ebene wird auf Null gesetzt, da diese Orientierung um die $z$-Achse für die Regelung nicht berücksichtigt wird.\newline
Mit den berechneten, virtuellen Drehmomenten kann auf die realen Drehmomente für die einzelnen Motoren nach Gl. \ref{eq:realeDrehmomente} umgerechnet werden. Damit der Zeitaufwand für Berechnung möglichst klein ist, werden konstante, mathematische Operationen durch feste Zahlenwerte festgelegt. Das Listing \ref{lst:Defines} zeigt einen Ausschnitt dieser Definitionen. 

\begin{lstlisting}[label=lst:Defines, style = C_colored_smallfont, caption=Zuweisen fester Zahlenwerte für eine kürzerer Berechnungsdauer]
#define ALPHA                           PI/4
#define BETA                            0
#define COS_ALPHA                       cos(ALPHA)       
#define SIN_ALPHA                       sin(ALPHA)
#define SIN_BETA                        sin(BETA)
#define COS_BETA                        cos(BETA)
#define SQRT3                           1.73205080757
\end{lstlisting}

 
\subsection{Ausgabe Drehmomente}
Das OpenCR-Board kommuniziert mit den Motoren über die RS485-Schnittstelle. Daher müssen für die Übertragung die berechneten Drehmomente in äquivalente, dimensionslose Einheiten (Unit) umgerechnet werden.
Diese Umrechnungskonstanten sind experimentell im Kapitel \ref{sec:Motoren} bestimmt worden. 

Da in der Modellbildung die Reibung zwischen Motor und Ball vernachlässigt wurde, muss ein Offset der Drehmomente eingestellt werden, damit diese Reibung überwunden werden kann \cite{ETHZ}.